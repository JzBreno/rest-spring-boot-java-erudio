fundamentos teoricos api rest
path paramans query params
tratamento de excecoes -> clases handle globais
verbos http -> get post put delete
spring data jpa -> repository -> service -> controller
logs no spring boot -> logback, SLF4J -> log4j2 -> log4j
padrao de projeto -> DTO -> Vo para view
versionamento de api -> por link /v2/, /v1/
migrations -> flyway -> resouseces.db.migration -> V1__init.sql, U2__alter_table.sql
custon Json serializarion -> @JsonSerialize, entre outros e config de json filter\
content negotiation -> {
        <dependency>
            <groupId>com.fasterxml.jackson.dataformat</groupId>
            <artifactId>jackson-dataformat-xml</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.dataformat</groupId>
            <artifactId>jackson-dataformat-yaml</artifactId>
        </dependency>
        para xml e yaml se deve configurar um webconfig para ajustar o que vai ser retornado
        para o yaml precisa de um serializer customizado
        podendo usar query, path mas Ã© recomendado usar header(evitar muitos parametros na url)
}

hateoas -> <dependency>
                       <groupId>org.springframework.hateoas</groupId>
                       <artifactId>spring-hateoas</artifactId>
                   </dependency>
apos isso teremos que informar que nossa classe suporta hateoas Extendendo  RepresentationModel<PersonDTO>:
public class PersonDTO extends RepresentationModel<PersonDTO>

podemos implementar no service, iremos centralizar as regras de negocio la
podemos criar o metodo de hateoas completo

private static void implementsHateoasPerson(PersonDTO personDTO) {
        personDTO.add(linkTo(methodOn(PersonController.class).findById(id)).withSelfRel().withType("GET"));
        personDTO.add(linkTo(methodOn(PersonController.class).findAll()).withRel("findAll").withType("GET"));
        personDTO.add(linkTo(methodOn(PersonController.class).deleteById(id)).withRel("deleteById").withType("DELETE"));
        personDTO.add(linkTo(methodOn(PersonController.class).createV1(personDTO)).withRel("createV1").withType("POST"));
        personDTO.add(linkTo(methodOn(PersonController.class).update(personDTO)).withRel("update").withType("PUT"));

    }

adicionando swagger no projeto

adicionando o swagger nas dependencias no pom.xml

<dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
</dependency>

configurando o que se deve documentar nesse projeto no properties

spring-doc:
  paths-to-match: /person/**/**
  swagger-ui:
    use-root-path: true

teremos que inserir anotacao na classe controller ex:
@Tag(name = "API REST Person", description = "Enpoint for managing Persons, version 1")

apos isso temos que inserir as anotacoes nos endpoints

ex:

@Operation(
            summary = "",
            description = "",
            tags = {""},
            responses = {
                    @ApiResponse(
                            description = "Success - Person found",
                            responseCode = "200",
                            content = {
                                    @Content(mediaType = MediaType.APPLICATION_JSON_VALUE, schema = @Schema(implementation = PersonDTO.class))
                            }),
                    @ApiResponse(
                            description = "Not Found - The person with the provided ID does not exist.",
                            responseCode = "404",
                            content = @Content),
                    ETC;
)